<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>exp_assignment1: armor_api.armor_manipulation_client.ArmorManipulationClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">exp_assignment1
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">package for the experimental labratory course first assignment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacearmor__api.html">armor_api</a></li><li class="navelem"><a class="el" href="namespacearmor__api_1_1armor__manipulation__client.html">armor_manipulation_client</a></li><li class="navelem"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html">ArmorManipulationClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">armor_api.armor_manipulation_client.ArmorManipulationClient Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for armor_api.armor_manipulation_client.ArmorManipulationClient:</div>
<div class="dyncontent">
<div class="center"><img src="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client__inherit__graph.png" border="0" usemap="#armor__api_8armor__manipulation__client_8_armor_manipulation_client_inherit__map" alt="Inheritance graph"/></div>
<map name="armor__api_8armor__manipulation__client_8_armor_manipulation_client_inherit__map" id="armor__api_8armor__manipulation__client_8_armor_manipulation_client_inherit__map">
<area shape="rect" title=" " alt="" coords="5,80,237,121"/>
<area shape="rect" title=" " alt="" coords="90,5,153,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for armor_api.armor_manipulation_client.ArmorManipulationClient:</div>
<div class="dyncontent">
<div class="center"><img src="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client__coll__graph.png" border="0" usemap="#armor__api_8armor__manipulation__client_8_armor_manipulation_client_coll__map" alt="Collaboration graph"/></div>
<map name="armor__api_8armor__manipulation__client_8_armor_manipulation_client_coll__map" id="armor__api_8armor__manipulation__client_8_armor_manipulation_client_coll__map">
<area shape="rect" title=" " alt="" coords="5,80,237,121"/>
<area shape="rect" title=" " alt="" coords="90,5,153,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a502c5f0547c5a125ff8ee71eab4d25d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a502c5f0547c5a125ff8ee71eab4d25d5">__init__</a> (self, client)</td></tr>
<tr class="separator:a502c5f0547c5a125ff8ee71eab4d25d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838c86bd80987124f99079377c0e1a1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a838c86bd80987124f99079377c0e1a1a">add_ind_to_class</a> (self, ind_name, class_name)</td></tr>
<tr class="separator:a838c86bd80987124f99079377c0e1a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b9e79036681e0b5843e5227327e86"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a782b9e79036681e0b5843e5227327e86">disj_inds_of_class</a> (self, class_name)</td></tr>
<tr class="separator:a782b9e79036681e0b5843e5227327e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc24c19cd97e8b4573d08916e5835fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a5cc24c19cd97e8b4573d08916e5835fa">add_objectprop_to_ind</a> (self, objectprop_name, ind_name, value_obj_name)</td></tr>
<tr class="separator:a5cc24c19cd97e8b4573d08916e5835fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f27571b6cf703c977a7499012f56e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a59f27571b6cf703c977a7499012f56e4">add_dataprop_to_ind</a> (self, dataprop_name, ind_name, value_type, value)</td></tr>
<tr class="separator:a59f27571b6cf703c977a7499012f56e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffd218532e67bf47c4adb32cc1d2779"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a8ffd218532e67bf47c4adb32cc1d2779">add_batch_dataprop_to_ind</a> (self, ind_name, dataprops)</td></tr>
<tr class="separator:a8ffd218532e67bf47c4adb32cc1d2779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2813162318cc5273002159a5f0dec265"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a2813162318cc5273002159a5f0dec265">replace_objectprop_b2_ind</a> (self, objectprop_name, ind_name, new_value, old_value)</td></tr>
<tr class="separator:a2813162318cc5273002159a5f0dec265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92edeab75032afbd267e205a345dab60"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a92edeab75032afbd267e205a345dab60">replace_dataprop_b2_ind</a> (self, dataprop_name, ind_name, value_type, new_value, old_value)</td></tr>
<tr class="separator:a92edeab75032afbd267e205a345dab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b26fbf899745e4798f0027d79c8a4d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a37b26fbf899745e4798f0027d79c8a4d">replace_one_dataprop_b2_ind</a> (self, dataprop_name, ind_name, value_type, new_value)</td></tr>
<tr class="separator:a37b26fbf899745e4798f0027d79c8a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a16c71dd6b4f5bd6052057456a73b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a5a9a16c71dd6b4f5bd6052057456a73b">replace_one_objectprop_b2_ind</a> (self, objectprop_name, ind_name, new_value)</td></tr>
<tr class="separator:a5a9a16c71dd6b4f5bd6052057456a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d996c8c0a4e46405284f959525bc9ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a5d996c8c0a4e46405284f959525bc9ee">remove_dataprop_from_ind</a> (self, dataprop_name, ind_name, value_type, value)</td></tr>
<tr class="separator:a5d996c8c0a4e46405284f959525bc9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209e25049f32e4931db9b8b7c9674acf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a209e25049f32e4931db9b8b7c9674acf">remove_objectprop_from_ind</a> (self, objectprop_name, ind_name, value)</td></tr>
<tr class="separator:a209e25049f32e4931db9b8b7c9674acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed759f30953773abf599082dc8ddbd6a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#aed759f30953773abf599082dc8ddbd6a">remove_batch_dataprop_to_ind</a> (self, ind_name, dataprops)</td></tr>
<tr class="separator:aed759f30953773abf599082dc8ddbd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12bb41653ea5f4ff279141cab415dd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarmor__api_1_1armor__manipulation__client_1_1_armor_manipulation_client.html#a8e12bb41653ea5f4ff279141cab415dd">remove_ind_from_class</a> (self, ind_name, class_name)</td></tr>
<tr class="separator:a8e12bb41653ea5f4ff279141cab415dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a502c5f0547c5a125ff8ee71eab4d25d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502c5f0547c5a125ff8ee71eab4d25d5">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>client</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8ffd218532e67bf47c4adb32cc1d2779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffd218532e67bf47c4adb32cc1d2779">&#9670;&nbsp;</a></span>add_batch_dataprop_to_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.add_batch_dataprop_to_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dataprops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add multiple dataprops to a single individual. Properties are passed as list of list, 
each element of the root list correspond to a property to add.
    
Args:
    ind_name (str): individual to assign the data property value.
    dataprops: list of [prop_name, value_type, value] objects
    
Returns:
    bool: True if ontology is consistent and every call succeeds,
  returns False on the first failed call
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
    
Note:
    If *value_type* and *value* does not match, *ArmorServiceInternalError* may be risen or you may break your 
    ontology consistency. Consistency can break even if you send a proper request but the ontology is expecting 
    a different value type.</pre> 
</div>
</div>
<a id="a59f27571b6cf703c977a7499012f56e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f27571b6cf703c977a7499012f56e4">&#9670;&nbsp;</a></span>add_dataprop_to_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.add_dataprop_to_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dataprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add a data property to an individual. If the data property to be assigned does not exist, it will be created.
    
Args:
    dataprop_name (str): name of the data property to assign.
    ind_name (str): individual to assign the data property value.
    value_type (str): type of the value to assign (INTEGER, INT, FLOAT, LONG, DOUBLE, STRING, BOOLEAN, BOOL).
    value (str): value as a string.
    
Returns:
    bool: True if ontology is consistent, else False
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
    
Note:
    If *value_type* and *value* does not match, *ArmorServiceInternalError* may be risen or you may break your 
    ontology consistency. Consistency can break even if you send a proper request but the ontology is expecting 
    a different value type.</pre> 
</div>
</div>
<a id="a838c86bd80987124f99079377c0e1a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838c86bd80987124f99079377c0e1a1a">&#9670;&nbsp;</a></span>add_ind_to_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.add_ind_to_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>class_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add an individual to a class.
    
Args:
    ind_name (str): individual to be added to the class.
    class_name (str): individual will be added to this class. It will be created a new class if it does not exist.
    
Returns:
    bool: True if ontology is consistent, else False
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
</pre> 
</div>
</div>
<a id="a5cc24c19cd97e8b4573d08916e5835fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc24c19cd97e8b4573d08916e5835fa">&#9670;&nbsp;</a></span>add_objectprop_to_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.add_objectprop_to_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>objectprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_obj_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add an object property to an individual. If the object property to be assigned does not exist, it will be created.
    
Args:
    objectprop_name (str): name of the object property to assign.
    ind_name (str): individual to assign the data property value.
    value_obj_name (str): name of the individual to be used as property value.
    
Returns:
    bool: True if ontology is consistent, else False
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
</pre> 
</div>
</div>
<a id="a782b9e79036681e0b5843e5227327e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782b9e79036681e0b5843e5227327e86">&#9670;&nbsp;</a></span>disj_inds_of_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.disj_inds_of_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>class_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Disjoint all individuals of a class.

Args:
class_name (str): class of the individuals to disjoint.

Returns:
bool: True if ontology is consistent, else False

Raises:
armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error

Note:
It returns the boolean consistency state of the ontology. This value is not updated to the last operation
if you are working in buffered reasoner or manipulation mode!</pre> 
</div>
</div>
<a id="aed759f30953773abf599082dc8ddbd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed759f30953773abf599082dc8ddbd6a">&#9670;&nbsp;</a></span>remove_batch_dataprop_to_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.remove_batch_dataprop_to_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dataprops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove multiple data properties from a single individual. Properties are passed as list of list,
each element of the root list correspond to a property to remove.

Args:
    ind_name (str): individual from which to remove the data properties values.
    dataprops: list of [prop_name, value_type, value] objects

Returns:
    bool: True if ontology is consistent and every call succeeds,
  returns False on the first failed call

Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error

Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!

Note:
    If *value_type* and *value* does not match, *ArmorServiceInternalError* may be risen or you may break your
    ontology consistency. Consistency can break even if you send a proper request but the ontology is expecting
    a different value type.</pre> 
</div>
</div>
<a id="a5d996c8c0a4e46405284f959525bc9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d996c8c0a4e46405284f959525bc9ee">&#9670;&nbsp;</a></span>remove_dataprop_from_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.remove_dataprop_from_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dataprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove a data property from an individual.

Args:
    dataprop_name (str): name of the data property to remove.
    ind_name (str): individual from which to remove the desired data property value.
    value_type (str): type of the value to remove (INTEGER, INT, FLOAT, LONG, DOUBLE, STRING, BOOLEAN, BOOL).
    value (str): value as a string.

Returns:
    bool: True if ontology is consistent, else False

Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error

Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!

Note:
    If *value_type* and *value* does not match, *ArmorServiceInternalError* may be risen or you may break your
    ontology consistency. Consistency can break even if you send a proper request but the ontology is expecting
    a different value type.
</pre> 
</div>
</div>
<a id="a8e12bb41653ea5f4ff279141cab415dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12bb41653ea5f4ff279141cab415dd">&#9670;&nbsp;</a></span>remove_ind_from_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.remove_ind_from_class </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>class_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove an individual from a class.

Args:
    ind_name (str): individual to be removed from the class.
    class_name (str): individual will be removed to this class. 

Returns:
    bool: True if ontology is consistent, else False

Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error

Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
</pre> 
</div>
</div>
<a id="a209e25049f32e4931db9b8b7c9674acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209e25049f32e4931db9b8b7c9674acf">&#9670;&nbsp;</a></span>remove_objectprop_from_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.remove_objectprop_from_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>objectprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove a object property from an individual.

Args:
    objectprop_name (str): name of the objet property to remove.
    ind_name (str): individual from which to remove the desired data property value.
    value (str): value to remove as a string.

Returns:
    bool: True if ontology is consistent, else False

Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error

Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!

Note:
    If *value_type* and *value* does not match, *ArmorServiceInternalError* may be risen or you may break your
    ontology consistency. Consistency can break even if you send a proper request but the ontology is expecting
    a different value type.
</pre> 
</div>
</div>
<a id="a92edeab75032afbd267e205a345dab60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92edeab75032afbd267e205a345dab60">&#9670;&nbsp;</a></span>replace_dataprop_b2_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.replace_dataprop_b2_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dataprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>old_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replace the value of a data property belonging to an individual. If the individual or the property instance to be
replaced do not exist, they will be created.
    
Args:
    dataprop_name (str): name of the data property to assign.
    ind_name (str): individual to assign the data property value.
    value_type (str): type of the value to assign (INTEGER, INT, FLOAT, LONG, DOUBLE, STRING, BOOLEAN, BOOL).
    new_value (str): new value of the data property.
    old_value (str): value of the data property to be replaced.
    
Returns:
    bool: True if ontology is consistent, else False.
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails.
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error.
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
    
Note:
    *old_value* is necessary since more than one object property instance may be applied to an individual. 
    Only the specified instance will be replaced.
    
Note:
    If *value_type* and *value* does not match, *ArmorServiceInternalError* may be risen or you may break your 
    ontology consistency. Consistency can break even if you send a proper request but the ontology is expecting 
    a different value type.
</pre> 
</div>
</div>
<a id="a2813162318cc5273002159a5f0dec265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2813162318cc5273002159a5f0dec265">&#9670;&nbsp;</a></span>replace_objectprop_b2_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.replace_objectprop_b2_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>objectprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>old_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replace the value of an object property belonging to an individual. If the individual or the property instance
to be replaced do not exist, they will be created.
    
Args:
    objectprop_name (str): name of the object property to replace.
    ind_name (str): individual whose property needs to be replaced.
    new_value (str): new value of the object property.
    old_value (str): value of the object property to be replaced.
    
Returns:
    bool: True if ontology is consistent, else False.
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails.
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error.
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
    
Note:
    *old_value* is necessary since more than one object property instance may be applied to an individual. 
    Only the specified instance will be replaced.
</pre> 
</div>
</div>
<a id="a37b26fbf899745e4798f0027d79c8a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b26fbf899745e4798f0027d79c8a4d">&#9670;&nbsp;</a></span>replace_one_dataprop_b2_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.replace_one_dataprop_b2_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dataprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">**Use with care:** Utility function that replace the value of the first returned data property value
associated to an individual without specifying the old value to be replaced. If the individual or the property 
instance to be replaced do not exist, they will be created. It is supposed to be used with single valued properties.
    
Args:
    dataprop_name (str): name of the data property to assign.
    ind_name (str): individual to assign the data property value.
    value_type (str): type of the value to assign (INTEGER, INT, FLOAT, LONG, DOUBLE, STRING, BOOLEAN, BOOL).
    new_value (str): value of the data property to be replaced.
    
Returns:
    bool: True if ontology is consistent, else False.
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails.
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error.
    
Note:
    This function is meant to be used when only one or less data property instance is expected to be associated
    to that individual. The function check this condition to protect your ontology and raises
    *ArmorServiceInternalError* if it is not satisfied.
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!
    
Note:
    If *value_type* and *value* does not match, *ArmorServiceInternalError* may be risen or you may break your 
    ontology consistency. Consistency can break even if you send a proper request but the ontology is expecting 
    a different value type.
</pre> 
</div>
</div>
<a id="a5a9a16c71dd6b4f5bd6052057456a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a16c71dd6b4f5bd6052057456a73b">&#9670;&nbsp;</a></span>replace_one_objectprop_b2_ind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def armor_api.armor_manipulation_client.ArmorManipulationClient.replace_one_objectprop_b2_ind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>objectprop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ind_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">**Use with care:** Utility function that replace the value of the first returned object property value
associated to an individual without specifying the old value to be replaced. If the individual or the property 
instance to be replaced do not exist, they will be created. It is supposed to be used with single valued properties.
    
Args:
    object_name (str): name of the object property to assign.
    ind_name (str): individual to assign the object property value.
    new_value (str): value of the object property to be replaced.
    
Returns:
    bool: True if ontology is consistent, else False.
    
Raises:
    armor_api.exceptions.ArmorServiceCallError: if call to ARMOR fails.
    armor_api.exceptions.ArmorServiceInternalError: if ARMOR reports an internal error.
    
Note:
    This function is meant to be used when only one or less object property instance is expected to be associated
    to that individual. The function check this condition to protect your ontology and raises
    *ArmorServiceInternalError* if it is not satisfied.
    
Note:
    It returns the boolean consistency state of the ontology. This value is not updated to the last operation
    if you are working in buffered reasoner or manipulation mode!</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>utilities/armor_api/<a class="el" href="armor__manipulation__client_8py.html">armor_manipulation_client.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
